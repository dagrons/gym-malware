import random
import gym
from collections import OrderedDict
from gym import error, spaces, utils
from gym.utils import seeding
import hashlib
import os
import lief

import numpy as np
from gym_malware.envs.utils import interface_v2, pefeatures

from gym_malware.envs.controls import manipulate2 as manipulate
ACTION_LOOKUP = {i: act for i, act in enumerate(
    manipulate.ACTION_TABLE.keys())}

# change this to function to the AV engine to attack
# function should be of the form
# def label_function( bytez ):
#    # returns 0.0 if benign else 1.0 if malware
label_function = interface_v2.get_label_local


class MalwareEnv(gym.Env):
    metadata = {'render.modes': ['human']}

    def __init__(self, sha256list, random_sample=True, maxturns=3, output_path='evaded/blackbox/', cache=False):
        self.cache = cache
        self.available_sha256 = sha256list
        self.action_space = spaces.Discrete(len(ACTION_LOOKUP))
        self.maxturns = maxturns
        self.feature_extractor = pefeatures.PEFeatureExtractor()
        self.random_sample = random_sample
        self.sample_iteration_index = 0
        self.output_path = os.path.join(
            os.path.dirname(
                os.path.dirname(
                    os.path.dirname(
                        os.path.abspath(__file__)))), output_path)
        if not os.path.exists(output_path):
            os.makedirs(output_path)

        self.history = OrderedDict()

        self.samples = {}
        if self.cache:
            for sha256 in self.available_sha256:
                try:
                    self.samples[sha256] = interface_v2.fetch_file(self.sha256)
                except interface_v2.FileRetrievalFailure:
                    print("failed fetching file")
                    continue  # try a new sha256...this one can't be retrieved from storage

        self._reset()

    def _step(self, action_index):
        self.turns += 1
        try: 
            self._take_action(action_index)  # update self.bytez
        except lief.bad_format as err:
            print("=========lief.bad_format==========")
            print(err)
            return self.observation_space, 0, True, {}

        # get reward
        try:
            self.label = label_function(self.bytez)
        except interface_v2.ClassificationFailure:
            print("Failed to classify file")
            episode_over = True
        else:
            self.observation_space = self.feature_extractor.extract(self.bytez)
            if self.label == 0:
                # we win!
                reward = 10.0  # !! a strong reward
                episode_over = True
                self.history[self.sha256]['evaded'] = True

                # store sample to output directory
                m = hashlib.sha256()
                m.update(self.bytez)
                sha256 = m.hexdigest()
                self.history[self.sha256]['evaded_sha256'] = sha256

                with open(os.path.join(self.output_path, sha256), 'wb') as outfile:
                    outfile.write(self.bytez)
            elif self.turns >= self.maxturns:
                # out of turns :(
                reward = 0.0
                episode_over = True
            else:
                reward = 0.0
                episode_over = False

        if episode_over:
            print("episode is over: reward = {}!".format(reward))

        return self.observation_space, reward, episode_over, {}

    def _take_action(self, action_index):
        assert action_index < len(ACTION_LOOKUP)
        action = ACTION_LOOKUP[action_index]
        print(action)
        self.history[self.sha256]['actions'].append(action)
        self.bytez = bytes(
            manipulate.modify_without_breaking(self.bytez, [action]))

    def _reset(self):
        self.turns = 0
        while True:
            # get the new environment
            if self.random_sample:
                self.sha256 = random.choice(self.available_sha256)
            else:  # draw a sample at random
                self.sha256 = self.available_sha256[self.sample_iteration_index % len(
                    self.available_sha256)]
                self.sample_iteration_index += 1

            self.history[self.sha256] = {'actions': [], 'evaded': False}
            if self.cache:
                self.bytez = self.samples[self.sha256]
            else:
                try:
                    self.bytez = interface_v2.fetch_file(self.sha256)
                except interface_v2.FileRetrievalFailure:
                    print("failed fetching file")
                    continue  # try a new sha256...this one can't be retrieved from storage
            try:
                original_label = label_function(self.bytez)
            except AttributeError as err:
                print("=======exception in reset=======")
                print("bytez=", self.bytez)
                print(err)
                return self._reset()

            if original_label == 0:
                # skip this one, it's already benign, and the agent will learn nothing
                continue

            print("new sha256: {}".format(self.sha256))

            self.observation_space = self.feature_extractor.extract(self.bytez)

            break  # we're done here

        return np.asarray(self.observation_space)

    def _render(self, mode='human', close=False):
        pass
